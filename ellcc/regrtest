#!/bin/sh
# regression tests

# This file contains a list of tests that should be run in ELLCC (via
# ./ecc or ./e++) before each commit.  With the exception of a few stored
# in the ellcc/in/big directory, they should be short tests that can be
# parsed and typechecked quickly.  When a big test fails (either one
# that is in ellcc/in/big, or some other external package), the failing
# syntax should be isolated and added to this file.
#
# The basic procedure for adding tests is to find the section that has
# tests for the language (C++, C, GNU extensions, etc.) the test uses,
# and append a line of the form
#
#   testparse foo.cc
#
# where the name 'testparse' will depend on the section the test
# appears in (because it selects the language).
#
# If the test is currently failing, but is intended to be fixed and
# therefore eventually succeed, use
#
#   failparse foo.cc "give reason here"
#
# The "reason" string, ideally, should include (1) what response
# ellcc gives (segfault, assertion failure, error message) and (2)
# what kind of syntax characterizes the input (e.g., "template with
# reference parameter").  The purpose of this string is to help me
# prioritize which tests to fix first.
#
# If the test includes deliberately invalid syntax that ellcc is
# supposed to detect and reject, then include lines in the test case
# of the form
#
#   //ERROR(n): some bad code;
#
# where 'n' is some number (like 1).  See multitest.pl for more
# details.


# default values for user parameters
skip=0
big=0
contin=0

# counters
curtest=0
success=0
failure=0
unexSuccess=0
unexFailure=0
skipdiagnose=0
runOneTest=false

usage() {
cat <<EOF
usage: $0 [options]
  -skip <n>    skip the first <n> tests
  -one <n>     run only test <n>
  -big         run the big, timeconsuming tests
  -contin      keep going even after a test fails (or succeeds) unexpectedly
  -help        print this message
EOF
}

# process args
while [ "$1" != "" ]; do
  case "$1" in
    -skip)
      shift
      skip="$1"
      ;;

    -one)
      shift
      skip="$1"
      runOneTest=true
      ;;

    -big)
      big=1
      ;;

    -contin)
      contin=1
      ;;

    -help)
      usage
      exit 0
      ;;

    *)
      echo "unknown arg: $1"
      usage
      exit 2
      ;;
  esac

  shift
done

# Occasionally there is an Elsa bug that eats all of memory, which
# causes the host system to become unhappy.  None of the tests in this
# file should require more than (or anything close to, really) 500MB.
ulimit -v 500000

# allow 'gmake' or whatever to be used instead of 'make'
MAKE=${MAKE:-make}

# clear the logfile
logfile=regrtest.log
rm -f $logfile

# write something to terminal and log
log() {
  echo "$@"
  echo "$@" >> $logfile
}


# run a single test, and bail if it fails
runTest() {
  if runTestInternal "$@"; then
    true
  else
    if [ $contin = 0 ]; then
      exit 2
    fi
  fi
}

# run a single test, and return 0 if it succeeds
runTestInternal() {
  result=0

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: skipping $*"
  else
    # print a visually distinctive banner
    echo "------------ [$curtest] $* ------------"
    ("$@")
    result=$?
    if [ $result -ne 0 ]; then
      unexFailure=`expr $unexFailure + 1`
      echo ""
      log  "[$curtest] A regression test command failed:"
      log  "  $*"
    else
      success=`expr $success + 1`
    fi

    if $runOneTest; then
      # exit with code 0 if the test succeeded
      exit `expr 1 - $success`
    fi
  fi

  curtest=`expr $curtest + 1`
  return $result
}

# run a big test, only if the user wants to
bigTest() {
  if [ $big = 1 ]; then
    runTest "$@"
  fi
}

# run a test that is expected to fail
#
# This is *not* intended for "here's a test that should fail", but
# rather "here's a test that does fail right now, but we want to
# eventually fix it".  The former can be handled using multitest.pl,
# or a similar mechanism for inverting the test sense.
failTest() {
  reason="$1"
  shift

  if [ "$reason" = "" ]; then
    echo "failTest $*: must supply a failure reason"
    exit 4
  fi

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: (fail) skipping $*"
  else
    echo "------------ [$curtest] (fail) $* ------------"
    if "$@"; then
      unexSuccess=`expr $unexSuccess + 1`
      echo ""
      log  "[$curtest] GOOD NEWS: A regression test that used to fail ($reason) now succeeds:"
      log  "  $*"
      if [ $contin = 0 ]; then
        exit 2
      fi
    else
      failure=`expr $failure + 1`
      echo "Failed as expected: $reason"
    fi

    if $runOneTest; then
      # exit with code 0 if the test failed
      exit `expr 1 - $failure`
    fi
  fi

  curtest=`expr $curtest + 1`
}

# run a failing big test
bigFail() {
  if [ $big = 1 ]; then
    failTest "$@"
  fi
}

# grep for lines containing both words, in first argument source file
grepBoth() {
  grep -w $2 $1 | grep -w $3
}


# ---------- test C++ parser ------------

# by using shell functions we can make it easy to comment-out
# or change to 'fail' status those tests that are not working at
# some given time
testparse() {
  runTest perl ./multitest.pl ./e++ in/$1
}

# run the parser with some specific tracing flag(s) added
testparse_special() {
  runTest perl ./multitest.pl ./e++ $1 in/$2
}

failparse() {
  if [ "$2" = "" ]; then
    echo "failparse $1: failparse takes two arguments"
    exit 4
  fi
  failTest "$2" perl ./multitest.pl ./e++ in/$1
}

failparse_special() {
  if [ "$3" = "" ]; then
    echo "failparse_special $2: failparse_special takes three arguments"
    exit 4
  fi
  failTest "$3" perl ./multitest.pl ./e++ -tr $1 in/$2
}

# ---- BEGIN: lots of tests ----
# (this block of tests is parsed by another program, so should stick to
# the uniform syntax below)
# testparse t0001.cc

# idempotency checks:

list=`echo "
    t0001.cc
  " | xargs -n 1 | sed 's|^|in/|'`

# RICH: runTest perl ./idemcheck -d outdir $list

# test the parser in C mode
testCparse() {
  runTest perl ./multitest.pl ./ecc in/$1
}
testCparse_special() {
  runTest perl ./multitest.pl ./ecc $1 in/$2
}
failCparse() {
  if [ "$2" = "" ]; then
    echo "failparse $1: failparse takes two arguments"
    exit 4
  fi
  failTest "$2" perl ./multitest.pl ./ecc in/$1
}
testCparse t0001.c
testCparse t0002.c


# is K&R built?
use_kandr=false
if egrep "USE_KANDR: +1" ../elsa/config.summary >/dev/null; then
  use_kandr=true
  echo "K&R extensions are enabled"
else
  echo "K&R extensions are not enabled"
fi

if $use_kandr; then
  # test the parser in C + K&R mode
  testKANDRparse() {
    runTest perl ./multitest.pl ./ecc -std=kandr in/$1
  }
  # testKANDRparse kandr/t0001.c
fi


# test GNU C
# is the gnu extension built?
use_gnu=false
if egrep "USE_GNU: +1" ../elsa/config.summary >/dev/null; then
  use_gnu=true
  echo "gnu extensions are enabled"
else
  echo "gnu extensions are not enabled"
fi

if $use_gnu; then
  echo "test gnu extensions"
#  testCparse gnu/t0001.c
fi

if false; then # rich
# final parser checks against the big files, since they've now become
# my performance measurement files
if $MAKE in/big; then

testnsparse() {
  runTest ./e++ "$1"
}
failnsparse() {
  failTest "$2" ./e++ "$1"
}
else
  # Even though my in/big/gz/nsAtomTable.i.gz has the right md5sum,
  # I can't convince gunzip to uncompress it under cygwin with text
  # mounts (which it should be ignoring since it's getting the file
  # contents via pipe, and ought to use O_BINARY anyway).
  echo "Skipping large file tests because could not uncompress them."
  echo "This may be due to a buggy cygwin gunzip."
fi

if [ "$DISABLE_BIG_TESTS" = "" ]; then
  echo "big tests"
  # put shorter tests first
#   testnsparse in/big/nonport.i

fi
fi # RICH

# final arithmetic to report result
echo ""
echo "use_gnu: $use_gnu"
echo "use_kandr: $use_kandr"
echo "Successful tests               :    $success"
echo "Failed as expected (known bugs):    $failure"
if [ $skipdiagnose -ne 0 ]; then
  echo "Fail to diag. cppstdex errors  :    $skipdiagnose"
fi
if [ $contin = 1 ]; then
  echo "Unexpected success:    $unexSuccess"
  echo "Unexpected failure:    $unexFailure"
  if [ -f "$logfile" ]; then
    cat "$logfile"
  fi
fi

